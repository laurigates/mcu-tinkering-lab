esphome:
  name: audiobook-player
  friendly_name: "Audiobook Player"
  on_boot:
    priority: -100  # Run after everything is initialized
    then:
      - script.execute: play_boot_sequence

esp32:
  board: ttgo-lora32-v2
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password
    on_begin:
      then:
        - deep_sleep.prevent: deep_sleep_control

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  on_connect:
    then:
      - script.execute: play_ready_sequence

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Audiobook-Player"
    password: !secret fallback_password

captive_portal:

# Deep sleep configuration for power management
deep_sleep:
  id: deep_sleep_control
  run_duration: 2min        # Stay awake for 2 minutes after wake
  wakeup_pin: GPIO27        # Tilt switch wakes device
  wakeup_pin_mode: INVERT_WAKEUP  # Wake when tilt switch closes (connects to GND)

# SPI bus configuration for RC522
# NOTE: Cannot use VSPI (GPIO18/19/23) - conflicts with onboard LoRa SX1276 chip
# Using alternative pins to avoid strapping pin conflicts
spi:
  id: rc522_spi_bus
  clk_pin: GPIO14   # Available on pin header
  miso_pin: GPIO35  # Input-only pin, safe for MISO, not a strapping pin
  mosi_pin: GPIO13  # Available on pin header
  interface: hardware

# RC522 RFID reader configuration
rc522_spi:
  spi_id: rc522_spi_bus
  cs_pin: GPIO15    # HSPI CS - strapping pin but generally OK
  # No reset_pin - RC522 uses power-on reset (avoids strapping pin conflicts)
  update_interval: 500ms

  # When a tag is detected, send it to Home Assistant
  on_tag:
    then:
      - text_sensor.template.publish:
          id: last_rfid_tag
          state: !lambda 'return x;'
      - homeassistant.tag_scanned: !lambda 'return x;'
      - homeassistant.event:
          event: esphome.audiobook_triggered
          data:
            device_id: audiobook-player
            tag_id: !lambda 'return x;'
      - logger.log:
          format: "Tag scanned: %s"
          args: ['x.c_str()']
      - script.execute: play_tag_success

  # When tag is removed
  on_tag_removed:
    then:
      - text_sensor.template.publish:
          id: last_rfid_tag
          state: ""
      - logger.log:
          format: "Tag removed: %s"
          args: ['x.c_str()']

# Text sensor to store the last scanned RFID tag
text_sensor:
  - platform: template
    name: "Last RFID Tag"
    id: last_rfid_tag
    icon: "mdi:card-account-details"

# Binary sensors for buttons
binary_sensor:
  # Green button - Play
  - platform: gpio
    pin:
      number: GPIO32  # Available GPIO pin
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Play Button"
    id: play_button
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_press:
      then:
        - homeassistant.event:
            event: esphome.audiobook_control
            data:
              action: play

  # Red button - Pause
  - platform: gpio
    pin:
      number: GPIO33  # Available GPIO pin
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Pause Button"
    id: pause_button
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_press:
      then:
        - homeassistant.event:
            event: esphome.audiobook_control
            data:
              action: pause

# Outputs for feedback indicators
output:
  # Status LED (built-in blue LED on TTGO LoRa32)
  - platform: gpio
    pin:
      number: GPIO25  # Built-in blue LED on TTGO LoRa32 V2
      inverted: true
    id: status_led_output

  # Piezo buzzer (PWM for tones)
  - platform: ledc
    pin: GPIO4  # Changed from GPIO25 (now used for status LED)
    id: buzzer_output

  # Vibration motor
  - platform: gpio
    pin: GPIO26
    id: vibration_output

# RTTTL buzzer for playing melodies
rtttl:
  output: buzzer_output
  id: buzzer_rtttl

# Scripts for feedback sequences
script:
  # Fast blink loop (100ms on/off) - runs until stopped
  - id: led_fast_blink
    mode: restart
    then:
      - while:
          condition:
            lambda: 'return true;'
          then:
            - output.turn_on: status_led_output
            - delay: 100ms
            - output.turn_off: status_led_output
            - delay: 100ms

  # Slow pulse loop (500ms on/off) - runs until stopped
  - id: led_slow_pulse
    mode: restart
    then:
      - while:
          condition:
            lambda: 'return true;'
          then:
            - output.turn_on: status_led_output
            - delay: 500ms
            - output.turn_off: status_led_output
            - delay: 500ms

  # Boot sequence - gentle ascending arpeggio
  - id: play_boot_sequence
    then:
      - script.execute: led_fast_blink
      - rtttl.play: "boot:d=16,o=5,b=120:c,d,e,g"
      - delay: 1s

  # Ready sequence - device is connected and ready
  - id: play_ready_sequence
    then:
      - script.stop: led_fast_blink
      - script.execute: led_slow_pulse
      - rtttl.play: "ready:d=8,o=5,b=140:c,e,g"

  # Tag scanned successfully
  - id: play_tag_success
    then:
      # Stop any running LED pattern
      - script.stop: led_fast_blink
      - script.stop: led_slow_pulse
      # Play success chime
      - rtttl.play: "success:d=8,o=5,b=180:g,8c6"
      # Flash LED solid
      - output.turn_on: status_led_output
      # Vibrate
      - output.turn_on: vibration_output
      - delay: 200ms
      - output.turn_off: vibration_output
      - delay: 100ms
      # Return to ready state
      - script.execute: led_slow_pulse

  # Error feedback
  - id: play_error_sequence
    then:
      - script.stop: led_slow_pulse
      - script.execute: led_fast_blink
      - rtttl.play: "error:d=8,o=5,b=140:e,c"
      # Triple vibration pulse
      - output.turn_on: vibration_output
      - delay: 100ms
      - output.turn_off: vibration_output
      - delay: 100ms
      - output.turn_on: vibration_output
      - delay: 100ms
      - output.turn_off: vibration_output
      - delay: 100ms
      - output.turn_on: vibration_output
      - delay: 100ms
      - output.turn_off: vibration_output

# Status LED as a simple light component (no effects to avoid brightness warnings)
light:
  - platform: binary
    name: "Status LED"
    id: status_led
    output: status_led_output
